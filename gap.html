<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UV-Vis Tauc Plotter & Bandgap Estimator</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body { background-color: #f4f6f9; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Layout: Top Navbar + Main Content */
        .main-container { flex: 1; display: flex; overflow: hidden; }
        
        /* Sidebar: Fixed width, Flex column to handle pinned buttons */
        .sidebar { 
            width: 350px; 
            min-width: 350px;
            background: white; 
            border-right: 1px solid #ddd; 
            display: flex; 
            flex-direction: column; 
            height: 100%;
            z-index: 10;
        }

        /* Sidebar Content: Scrollable area for inputs */
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Sidebar Footer: Pinned to bottom */
        .sidebar-footer {
            padding: 15px 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
        }

        /* Plot Area */
        .plot-area { 
            flex: 1; 
            background: #fff; 
            padding: 20px; 
            overflow-y: auto; 
            display: flex; 
            flex-direction: column; 
        }

        /* Elements */
        .card-header { font-weight: bold; font-size: 0.9rem; }
        #plotDiv, #directPlotDiv, #indirectPlotDiv { width: 90%; aspect-ratio: 1/1; max-height: 60vh; margin: 20 auto; }
        .results-table td, .results-table th { font-size: 0.85rem; padding: 4px 8px; }
        .nav-tabs .nav-link.active { font-weight: bold; border-top: 3px solid #0d6efd; color: #0d6efd; background-color: #fff; border-bottom-color: transparent; }
        
        /* Hide class utility */
        .d-none-custom { display: none !important; }
    </style>
</head>
<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark py-2 flex-shrink-0">
    <div class="container-fluid">
        <span class="navbar-brand mb-0 h1">Bandgap Estimator <span style="font-size:0.7em; opacity:0.7;">UV-VIS Analysis Tool</span></span>
    </div>
</nav>

<div class="main-container">
    
    <div class="sidebar">
        <div class="sidebar-content">
            <h5 class="mb-3 text-primary">1. Data Import</h5>
            <div class="mb-3">
                <input class="form-control" type="file" id="fileInput" multiple accept=".csv, .txt, .dat">
                <div class="form-text">Supports CSV/TXT (Space, Tab, or Comma separated).</div>
            </div>

            <div class="card mb-3">
                <div class="card-header bg-light">Input Parameters</div>
                <div class="card-body">
                    <div class="row g-2 mb-2">
                        <div class="col-6">
                            <label class="form-label small">X-Axis Unit</label>
                            <select id="xUnit" class="form-select form-select-sm" onchange="recalculateAll()">
                                <option value="nm">Wavelength (nm)</option>
                                <option value="ev">Energy (eV)</option>
                            </select>
                        </div>
                        <div class="col-6">
                            <label class="form-label small">Y-Axis Type</label>
                            <select id="yType" class="form-select form-select-sm" onchange="handleYTypeChange()">
                                <option value="abs">Absorbance (A)</option>
                                <option value="trans">Transmittance (%)</option>
                                <option value="refl">Reflectance (%)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row g-2" id="thicknessGroup">
                         <div class="col-12">
                            <label class="form-label small">Sample Thickness (cm)</label>
                            <input type="number" id="thickness" class="form-control form-control-sm" value="1.0" step="0.0001" onchange="recalculateAll()">
                            <div class="form-text" style="font-size: 0.75rem;">Required for α calculation (Abs/Trans modes).</div>
                         </div>
                    </div>
                </div>
            </div>

            <h5 class="mb-2 text-primary">2. Analysis Controls</h5>
            <div class="card mb-3">
                <div class="card-header bg-light">Linear Fit Range (Energy eV)</div>
                <div class="card-body">
                    <p class="small text-muted mb-2">Adjust range to select linear region for Eg fitting. <br><strong>Tip:</strong> If Eg is negative, increase Min eV.</p>
                    <div class="input-group input-group-sm mb-2">
                        <span class="input-group-text">Min eV</span>
                        <input type="number" id="fitMin" class="form-control" step="0.1" onchange="recalculateAll()">
                    </div>
                    <div class="input-group input-group-sm">
                        <span class="input-group-text">Max eV</span>
                        <input type="number" id="fitMax" class="form-control" step="0.1" onchange="recalculateAll()">
                    </div>
                    <button class="btn btn-sm btn-outline-secondary w-100 mt-2" onclick="autoDetectRange()">Auto-Suggest Range</button>
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
            <div class="d-grid gap-2">
                <button id="btnDownload" class="btn btn-success" disabled onclick="downloadCSV()">Download CSV</button>
                <button id="btnReport" class="btn btn-primary" disabled onclick="generatePDF()">Generate PDF Report</button>
            </div>
        </div>
    </div>

    <div class="plot-area">
        <ul class="nav nav-tabs mb-3" id="myTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="raw-tab" data-bs-toggle="tab" data-bs-target="#raw" type="button">Raw Spectra</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="direct-tab" data-bs-toggle="tab" data-bs-target="#direct" type="button">Direct Bandgap</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="indirect-tab" data-bs-toggle="tab" data-bs-target="#indirect" type="button">Indirect Bandgap</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="help-tab" data-bs-toggle="tab" data-bs-target="#help" type="button">Help & Theory</button>
            </li>
        </ul>

        <div class="tab-content h-100" id="myTabContent">
            <div class="tab-pane fade show active" id="raw" role="tabpanel">
                <div id="plotDiv"></div>
            </div>

            <div class="tab-pane fade" id="direct" role="tabpanel">
                <div id="directPlotDiv"></div>
                <div class="mt-3">
                    <h6>Calculated Results (Direct)</h6>
                    <table class="table table-bordered table-sm results-table" id="directTable">
                        <thead class="table-light"><tr><th>File</th><th>Eg (eV)</th><th>R²</th><th>Slope</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="tab-pane fade" id="indirect" role="tabpanel">
                <div id="indirectPlotDiv"></div>
                <div class="mt-3">
                    <h6>Calculated Results (Indirect)</h6>
                    <table class="table table-bordered table-sm results-table" id="indirectTable">
                        <thead class="table-light"><tr><th>File</th><th>Eg (eV)</th><th>R²</th><th>Slope</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="tab-pane fade" id="help" role="tabpanel">
                <div class="p-4" style="max-width: 800px;">
                    <h4 class="mb-3">Theory & Operation</h4>
                    
                    <h5 class="mt-4">1. Absorbance & Transmittance Mode</h5>
                    <p>For standard transmission measurements (liquids/films), the Tauc plot is based on the Absorption Coefficient (<b>&alpha;</b>).</p>
                    <ul>
                        <li>If input is <strong>Transmittance (%T)</strong>: 
                            <br><code>A = 2 - log<sub>10</sub>(%T)</code>
                        </li>
                        <li><strong>Absorption Coefficient (&alpha;):</strong> 
                            <br><code>&alpha; = (2.303 &times; A) / d</code> 
                            <br>where <em>d</em> is the <strong>sample thickness</strong> in cm.
                        </li>
                    </ul>

                    <h5 class="mt-4">2. Reflectance Mode (Kubelka-Munk)</h5>
                    <p>For diffuse reflectance (powders/opaque samples), the code uses the <strong>Kubelka-Munk function F(R)</strong>. This method does <u>not</u> depend on thickness.</p>
                    <ul>
                        <li>The reflectance <em>R</em> is normalized (0 &lt; R &lt; 1): 
                            <br><code>R<sub>norm</sub> = R<sub>%</sub> / 100</code>
                        </li>
                        <li><strong>Kubelka-Munk Function:</strong> 
                            <br><code>F(R) = (1 - R<sub>norm</sub>)<sup>2</sup> / (2 &times; R<sub>norm</sub>)</code>
                        </li>
                    </ul>

                    <h5 class="mt-4">3. Plot Y-Axis Logic</h5>
                    <ul>
                        <li><strong>Direct Bandgap:</strong> Plot fits <code>(Y &times; h&nu;)<sup>2</sup></code> vs Energy.</li>
                        <li><strong>Indirect Bandgap:</strong> Plot fits <code>(Y &times; h&nu;)<sup>0.5</sup></code> vs Energy.</li>
                        <li><em>(Where Y is either &alpha; or F(R) depending on the mode selected)</em>.</li>
                    </ul>

                    
                </div>
            </div>


        </div>
    </div>
</div>

<script>
    // --- Global State ---
    let datasets = []; 
    const fileInput = document.getElementById('fileInput');
    
    // --- Event Listeners ---
    fileInput.addEventListener('change', handleFiles);

    // --- UI Logic ---
    function handleYTypeChange() {
        const yType = document.getElementById('yType').value;
        const thicknessGroup = document.getElementById('thicknessGroup');
        
        // Hide Thickness for Reflectance, Show for Abs/Trans
        if (yType === 'refl') {
            thicknessGroup.classList.add('d-none-custom');
        } else {
            thicknessGroup.classList.remove('d-none-custom');
        }
        recalculateAll();
    }

    // --- File Handling ---
    function handleFiles(e) {
        const files = e.target.files;
        if (!files.length) return;

        datasets = []; 
        let filesLoaded = 0;

        Array.from(files).forEach(file => {
            Papa.parse(file, {
                delimiter: "", 
                skipEmptyLines: true,
                dynamicTyping: true,
                complete: function(results) {
                    processRawData(file.name, results.data);
                    filesLoaded++;
                    if (filesLoaded === files.length) {
                        smartDetectParams(); 
                        autoDetectRange();   
                    }
                }
            });
        });
    }

    function processRawData(filename, data) {
        let cleanData = data.filter(row => {
            return row.length >= 2 && typeof row[0] === 'number' && typeof row[1] === 'number';
        });

        // Ensure sorted by X
        cleanData.sort((a, b) => a[0] - b[0]);

        const rawX = cleanData.map(r => r[0]);
        const rawY = cleanData.map(r => r[1]);

        datasets.push({
            name: filename,
            rawX: rawX,
            rawY: rawY,
            eV: [], alphaOrF: [], directY: [], indirectY: [],
            fitDirect: {}, fitIndirect: {}
        });
    }

    // --- Smart Detection ---
    function smartDetectParams() {
        if (datasets.length === 0) return;
        const d = datasets[0];
        
        // Detect X Unit
        const maxX = Math.max(...d.rawX);
        const xSelect = document.getElementById('xUnit');
        xSelect.value = (maxX > 150) ? 'nm' : 'ev';

        // Detect Y Type
        const maxY = Math.max(...d.rawY);
        const ySelect = document.getElementById('yType');
        
        // Heuristic: If Y > 5, likely % (Trans/Refl). If < 4, likely Abs.
        if (maxY > 5) {
            ySelect.value = 'refl'; // Default to refl for high values
        } else {
            ySelect.value = 'abs';
        }
        handleYTypeChange(); // Update UI visibility based on guess
    }

    function autoDetectRange() {
        if (datasets.length === 0) return;
        
        const isNm = document.getElementById('xUnit').value === 'nm';
        let allEv = [];
        datasets[0].rawX.forEach(x => {
            allEv.push(isNm ? 1239.84 / x : x);
        });

        const minE = Math.min(...allEv);
        const maxE = Math.max(...allEv);
        
        // Default fit range: Top 40% of energy spectrum
        document.getElementById('fitMin').value = (minE + (maxE - minE) * 0.5).toFixed(2);
        document.getElementById('fitMax').value = maxE.toFixed(2);

        recalculateAll();
    }

    // --- Calculations ---
    function recalculateAll() {
        if(datasets.length === 0) return;

        const xUnit = document.getElementById('xUnit').value;
        const yType = document.getElementById('yType').value;
        let thickness = parseFloat(document.getElementById('thickness').value);
        const fitMin = parseFloat(document.getElementById('fitMin').value);
        const fitMax = parseFloat(document.getElementById('fitMax').value);

        if (!thickness || thickness <= 0) thickness = 1.0; 

        // Enable buttons
        document.getElementById('btnDownload').disabled = false;
        document.getElementById('btnReport').disabled = false;

        datasets.forEach(ds => {
            ds.eV = [];
            ds.alphaOrF = [];
            ds.directY = [];
            ds.indirectY = [];

            for (let i = 0; i < ds.rawX.length; i++) {
                const x = ds.rawX[i];
                const y = ds.rawY[i];

                // 1. Calculate eV
                let energy = (xUnit === 'nm') ? (1239.84 / x) : x;
                ds.eV.push(energy);

                // 2. Process Y based on mode
                let valForTauc = 0; // Will be alpha or F(R)

                if (yType === 'refl') {
                    // --- Kubelka-Munk Mode ---
                    // R is %, convert to 0-1
                    let R = y / 100;
                    // Clamp to avoid division by zero or negative logs
                    if (R <= 0.0001) R = 0.0001; 
                    if (R >= 1) R = 0.9999;
                    
                    // F(R) = (1-R)^2 / 2R
                    valForTauc = Math.pow(1 - R, 2) / (2 * R);
                    
                } else {
                    // --- Standard Abs/Trans Mode ---
                    let A = 0;
                    if (yType === 'abs') {
                        A = y;
                    } else if (yType === 'trans') {
                        // T is %, A = 2 - log(T)
                        let T = y;
                        if (T <= 0.0001) T = 0.0001;
                        A = 2 - Math.log10(T);
                    }
                    if (A < 0) A = 0;

                    // Calculate Alpha (cm^-1)
                    valForTauc = (2.303 * A) / thickness;
                }

                ds.alphaOrF.push(valForTauc);

                // 3. Tauc Y-axes
                // Direct: (val * hv)^2
                ds.directY.push(Math.pow(valForTauc * energy, 2));
                // Indirect: (val * hv)^1/2
                ds.indirectY.push(Math.pow(valForTauc * energy, 0.5));
            }

            // Perform Fits
            ds.fitDirect = performLinearFit(ds.eV, ds.directY, fitMin, fitMax);
            ds.fitIndirect = performLinearFit(ds.eV, ds.indirectY, fitMin, fitMax);
        });

        updatePlots();
        updateTables();
    }

    function performLinearFit(xData, yData, minX, maxX) {
        let n = 0;
        let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
        let validPoints = [];

        for (let i = 0; i < xData.length; i++) {
            if (xData[i] >= minX && xData[i] <= maxX) {
                validPoints.push({x: xData[i], y: yData[i]});
                sumX += xData[i];
                sumY += yData[i];
                sumXY += (xData[i] * yData[i]);
                sumXX += (xData[i] * xData[i]);
                n++;
            }
        }

        if (n < 2) return { m: 0, c: 0, Eg: 0, R2: 0 };

        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;

        // R2 Calc
        let ssTot = 0, ssRes = 0;
        const yMean = sumY / n;
        validPoints.forEach(p => {
            const yPred = slope * p.x + intercept;
            ssTot += Math.pow(p.y - yMean, 2);
            ssRes += Math.pow(p.y - yPred, 2);
        });
        const R2 = 1 - (ssRes / ssTot);

        const Eg = -intercept / slope;

        return { m: slope, c: intercept, Eg: Eg, R2: R2 };
    }


    

    function updatePlots() {
        const yType = document.getElementById('yType').value;
        const yLabelBase = (yType === 'refl') ? 'F(R)' : 'α';
        
        const layoutCommon = {
            margin: { t: 40, r: 20, l: 60, b: 60 },
            showlegend: true,
            legend: { x: 0.05, y: 0.95 },
            // Autosize is true by default, but relying on CSS aspect-ratio requires 'responsive' config below
        };

        const configCommon = { responsive: true }; //  update with container size

        // 1. Raw Spectra
        const rawTraces = datasets.map(ds => ({
            x: ds.rawX,
            y: ds.rawY,
            mode: 'lines',
            name: ds.name
        }));
        
        const xLab = document.getElementById('xUnit').value === 'nm' ? 'Wavelength (nm)' : 'Energy (eV)';
        
        // Define Y-Label based on selection
        let yLabRaw = "Value"; 
        if (yType === 'abs') yLabRaw = "Absorbance (a.u.)";
        else if (yType === 'trans') yLabRaw = "Transmittance (%)";
        else if (yType === 'refl') yLabRaw = "Reflectance (%)";

        Plotly.newPlot('plotDiv', rawTraces, 
            { ...layoutCommon, title: 'Raw Spectra', xaxis: {title: xLab}, yaxis: {title: yLabRaw} }, 
            configCommon
        );



        // 2. Direct Plot
        let directTraces = [];
        datasets.forEach(ds => {
            directTraces.push({ x: ds.eV, y: ds.directY, mode: 'lines', name: ds.name, line: {width: 2} });
            if (ds.fitDirect.m !== 0) {
                const fitX = [ds.fitDirect.Eg, Math.max(...ds.eV)];
                const fitY = [0, ds.fitDirect.m * Math.max(...ds.eV) + ds.fitDirect.c];
                directTraces.push({ 
                    x: fitX, y: fitY, mode: 'lines', name: `Fit (Eg=${ds.fitDirect.Eg.toFixed(2)})`,
                    line: { dash: 'dot', width: 1, color: 'orange' } 
                });
            }
        });
        Plotly.newPlot('directPlotDiv', directTraces, 
            { ...layoutCommon, title: `Direct Bandgap: (${yLabelBase}hν)² vs Energy`, xaxis: {title: 'Energy (eV)'}, yaxis: {title: `(${yLabelBase}hν)²`} }, 
            configCommon
        );

        // 3. Indirect Plot
        let indirectTraces = [];
        datasets.forEach(ds => {
            indirectTraces.push({ x: ds.eV, y: ds.indirectY, mode: 'lines', name: ds.name, line: {width: 2} });
            if (ds.fitIndirect.m !== 0) {
                const fitX = [ds.fitIndirect.Eg, Math.max(...ds.eV)];
                const fitY = [0, ds.fitIndirect.m * Math.max(...ds.eV) + ds.fitIndirect.c];
                indirectTraces.push({ 
                    x: fitX, y: fitY, mode: 'lines', name: `Fit (Eg=${ds.fitIndirect.Eg.toFixed(2)})`,
                    line: { dash: 'dot', width: 1, color: 'orange' } 
                });
            }
        });
        Plotly.newPlot('indirectPlotDiv', indirectTraces, 
            { ...layoutCommon, title: `Indirect Bandgap: (${yLabelBase}hν)½ vs Energy`, xaxis: {title: 'Energy (eV)'}, yaxis: {title: `(${yLabelBase}hν)½`} }, 
            configCommon
        );
    }

    function updateTables() {
        const updateTbody = (id, key) => {
            const tbody = document.querySelector(`#${id} tbody`);
            tbody.innerHTML = '';
            datasets.forEach(ds => {
                const fit = ds[key];
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${ds.name}</td><td><strong>${fit.Eg.toFixed(3)}</strong></td><td>${fit.R2.toFixed(4)}</td><td>${fit.m.toExponential(2)}</td>`;
                tbody.appendChild(tr);
            });
        };
        updateTbody('directTable', 'fitDirect');
        updateTbody('indirectTable', 'fitIndirect');
    }

    // --- Export Functions ---
    function downloadCSV() {
        if (!datasets || datasets.length === 0) {
            alert("No data available to download.");
            return;
        }
        
        // Helper to safely format cells (handles commas in filenames)
        const esc = (val) => {
            if (val === null || val === undefined) return "";
            const str = String(val);
            return str.includes(",") ? `"${str}"` : str;
        };

        let rows = [];

        // --- SECTION 1: SUMMARY OF RESULTS ---
        rows.push(["=== SUMMARY RESULTS ==="]);
        rows.push(["File Name", "Bandgap Mode", "Eg (eV)", "R-Squared", "Slope", "Intercept"].join(","));

        datasets.forEach(ds => {
            // Add Direct Bandgap Result
            rows.push([
                esc(ds.name), 
                "Direct (n=2)", 
                ds.fitDirect.Eg.toFixed(4), 
                ds.fitDirect.R2.toFixed(4), 
                ds.fitDirect.m.toExponential(4),
                ds.fitDirect.c.toExponential(4)
            ].join(","));
            
            // Add Indirect Bandgap Result
            rows.push([
                esc(ds.name), 
                "Indirect (n=1/2)", 
                ds.fitIndirect.Eg.toFixed(4), 
                ds.fitIndirect.R2.toFixed(4), 
                ds.fitIndirect.m.toExponential(4),
                ds.fitIndirect.c.toExponential(4)
            ].join(","));
        });

        rows.push([]); // Spacer row
        rows.push([]); 
        rows.push(["=== SPECTRAL DATA ==="]);

        // --- SECTION 2: FULL DATA TABLE ---
        // 1. Build Headers
        let dataHeader = ["Index"];
        datasets.forEach(ds => {
            const n = esc(ds.name);
            dataHeader.push(`${n}_Energy(eV)`);
            dataHeader.push(`${n}_RawInput`);
            dataHeader.push(`${n}_Processed_Y(Alpha_or_F(R))`);
            dataHeader.push(`${n}_Direct_Tauc_Y`);
            dataHeader.push(`${n}_Indirect_Tauc_Y`);
        });
        rows.push(dataHeader.join(","));

        // 2. Build Data Rows
        const maxLen = Math.max(...datasets.map(d => d.eV.length));

        for (let i = 0; i < maxLen; i++) {
            let row = [i];
            datasets.forEach(ds => {
                if (i < ds.eV.length) {
                    // Precision fixed to 5 decimals to keep file size reasonable but accurate
                    row.push(ds.eV[i].toFixed(5));
                    row.push(ds.rawY[i].toFixed(5));
                    // Handle potential undefined for processed arrays
                    row.push(ds.alphaOrF && ds.alphaOrF[i] !== undefined ? ds.alphaOrF[i].toFixed(5) : "");
                    row.push(ds.directY && ds.directY[i] !== undefined ? ds.directY[i].toFixed(5) : "");
                    row.push(ds.indirectY && ds.indirectY[i] !== undefined ? ds.indirectY[i].toFixed(5) : "");
                } else {
                    // Empty cells if this file has fewer points than the longest file
                    row.push("","","","","");
                }
            });
            rows.push(row.join(","));
        }

        // --- CREATE BLOB & DOWNLOAD ---
        const csvString = rows.join("\r\n");
        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", `tauc_analysis_full_${Date.now()}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function generatePDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const date = new Date().toLocaleString();
        const yType = document.getElementById('yType').value;

        doc.setFontSize(16);
        doc.text("UV-VIS Tauc Plot Report", 14, 20);
        doc.setFontSize(10);
        doc.text(`Generated: ${date}`, 14, 26);
        doc.text(`Analysis Mode: ${yType.toUpperCase()}`, 14, 32);
        
        if (yType !== 'refl') {
            doc.text(`Thickness Used: ${document.getElementById('thickness').value} cm`, 14, 38);
        } else {
            doc.text(`Thickness: N/A (Kubelka-Munk)`, 14, 38);
        }

        let yPos = 46;
        const addTableToPdf = (title, tableId) => {
            doc.setFontSize(12);
            doc.text(title, 14, yPos);
            yPos += 7;
            doc.setFontSize(10);
            
            const table = document.getElementById(tableId);
            const rows = table.querySelectorAll('tr');
            rows.forEach(row => {
                let xPos = 14;
                const cols = row.querySelectorAll('th, td');
                let rowText = "";
                cols.forEach(col => { rowText += col.innerText.padEnd(25, " ").substring(0, 25) + " "; });
                doc.text(rowText, xPos, yPos);
                yPos += 5;
            });
            yPos += 10;
        };

        addTableToPdf("Direct Bandgap Results:", "directTable");
        addTableToPdf("Indirect Bandgap Results:", "indirectTable");

        // Grab plot images
        const grabPlot = async (divId) => {
            return await Plotly.toImage(document.getElementById(divId), {format: 'png', width: 600, height: 400});
        };

        if (yPos > 200) { doc.addPage(); yPos = 20; }
        const imgDirect = await grabPlot('directPlotDiv');
        doc.text("Direct Tauc Plot:", 14, yPos);
        doc.addImage(imgDirect, 'PNG', 15, yPos + 5, 180, 100);
        
        doc.addPage();
        doc.text("Indirect Tauc Plot:", 14, 20);
        const imgIndirect = await grabPlot('indirectPlotDiv');
        doc.addImage(imgIndirect, 'PNG', 15, 25, 180, 100);

        doc.save(`Tauc_Report_${Date.now()}.pdf`);
    }
</script>

</body>
</html>